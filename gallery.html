<html>

<head>
  <title> odyssee - Gallery </title>
  <meta charset="utf-8"/>
  <link rel="stylesheet" type="text/css" href="styles/all.css" media="all"/>
  <link rel="stylesheet" href="https://use.typekit.net/qep5qwj.css"/>
  <link rel="icon" type="image/png" href="images/icon.png"/>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://d3js.org/d3-drag.v1.min.js"></script>
</head>
  <ul>
    <li style="float:right;vertical-align:top"><a href="about.html">About</a></li>
  </ul>
<body>
<br>
<p style="font-family:Courier New; font-size: 23; text-align: center; margin-left:auto; margin-right:auto; padding-top:50;">Welcome to your odyssee portal!</p>

<div style= "text-align: center; color: #fff8eb; margin-bottom: 20px; display:block;">
  <svg style="margin-top: 100;margin-bottom: 100" height="700" width="1000" class="indTwoWeeks"/>
  <svg style="margin-top: 20; margin-bottom: 100" height="700" width="1000" class="aggTwoWeeks"/>
  <svg style="margin-top: 20; margin-bottom: 100" height="700" width="1000" class="indBursts"/>
</div>
  <script>
    let data;
    let email = "lh484@cornell.edu"; //hardcoded
    let personData = [];
    let width = 1000;
    let height = 700;
    let padding = 50;
    let numIcons = 6;
    let textColor = "#484848";
    let backgroundColor = "#fff8eb";
    let iconWidth = 70;


    let moodList = ["Awful", "Bad", "Ok", "Good", "Amazing"];
    let attitudeList = ["want to", "have to", "both", "neither"];
    let dashArray2 = ["0.25 7", "5 7", "0.25 7 5 7","1000"];
    let dashArray = {"I want to": "0.25 5", "I have to": "5 5", "I want to and have to": "0.25 5 5 5", "of something else; I neither want to nor have to": "1000"};
    let attitudeLongtoShort = {"I want to": "want to", "I have to": "have to", "I want to and have to": "both", "of something else; I neither want to nor have to": "neither"};
    let colorHexArray = {"Awful": "#9f265b", "Bad": "#ca614d", "Ok": "#edc3a3", "Good": "#f2d878", "Amazing": "#ffc500"};

    const getData = async () => {
      // TODO for Jamal: replace next two lines with json list
      // personData = getPersonData(data, email);
      personData = await d3.json("fakeData.txt");
      var everyoneData = await d3.csv("odyssee_data.csv");


      var categoryMap = getFrequencyByKey("Activity", personData);
      var categoryFullMap = getFrequencyByKey("Activity", personData, 1);
      drawMoodByActvitiy(".indTwoWeeks", categoryMap, categoryFullMap, "Your last 2 weeks", personData);
      drawMoodByActivityBursts(".indBursts", categoryMap, everyoneData, "Mood by Activity");

      var categoryMap2 = getFrequencyByKey("Activity", everyoneData);
      var categoryFullMap2 = getFrequencyByKey("Activity", everyoneData, 1);
      drawMoodByActvitiy(".aggTwoWeeks", categoryMap2, categoryFullMap2, "Everyone's last 2 weeks", everyoneData);

    }

    // returns list of all data entries for a person
    function getPersonData(data, name) {
      var list = [];
      data.forEach(function (d) {
        if (d.Email == name) {
          list.push(d);
        }
      });

      return list;
    }


    /** 
    *   str: column name in excel, ie Activity, Reason, Feeling
    *   data: list of data entries 
    *   index: used for split (ie. "b5" or "Intellectual")
    *   returns sorted map of keys to frequency, ie ("b5: 24")
    */
    function getFrequencyByKey(str, data, index = 0) {
      let map = new Map();
      for (var i = 0 ; i < data.length; i++) {
        let key = data[i][str].split(":")[index];
        if (!map.has(key)) {
          map.set(key, 1);
        } else {
          map.set(key, map.get(key)+1);
        }
      }

      let sortedMap = new Map([...map.entries()].sort((a, b) => b[1] - a[1]));

      return sortedMap;
    }


    /** 
    *   data: list of data entries
    *   returns sorted map divided first by str1 then by str2
    */
    function getFrequencyByKeys(str1, str2, data) {
      let map = {};
      for (var i = 0 ; i < data.length; i++) {
        let key = data[i][str1].split(":")[0];
        let key2 = data[i][str2];
        if (!(key in map)) {
          map[key] = {};
          map[key][key2] = 1
        } else {
          map[key][key2] = !(key2 in map[key]) ? 1 : (map[key][key2] + 1);
        }
      }

      // var sortedMap = new Map([...map.entries()].sort((a, b) => b[1] - a[1]));

      return map;
    }


    /** 
    *   data: list of data entries
    *   returns sorted map divided first by str1 then by str2, then by str3
    */
    function getFrequencyByThreeKeys(str1, str2, str3, keyList, data) {
      let map = {};
      for (var i = 0 ; i < data.length; i++) {
      
        let key = data[i][str1].split(":")[0];
        if (keyList.indexOf(key) != -1) {
          let key2 = data[i][str2];
          let key3 = data[i][str3];
          if (!(key in map)) {
            map[key] = {};
            map[key][key2] = {};
            map[key][key2][key3] = 1;
          } else if (!(key2 in map[key])){
            map[key][key2] = {};
            map[key][key2][key3] = 1;
          } else if (!(key3 in map[key][key2])) {
            map[key][key2][key3] = 1;
          } else {
            map[key][key2][key3] = map[key][key2][key3] + 1;
          }
        }
      }

      return map;
    }


    // add color filters to website, must call this per svg 
    function setUpFilters(svgClass) {
      let svg = d3.select(svgClass);
      svg.append('filter')
        .attr('id','Amazing')
        .append('feColorMatrix')
        .attr('type','matrix')
        .attr('color-interpolation-filters', 'sRGB')
        .attr('values',"0 0 0 0 1 0 0 0 0 0.772549 0 0 0 0 0 0 0 0 1 0");

      svg.append('filter')
        .attr('id','Good')
        .append('feColorMatrix')
        .attr('type','matrix')
        .attr('color-interpolation-filters', 'sRGB')
        .attr('values',"0 0 0 0 0.9490196 0 0 0 0 0.84705882 0 0 0 0 0.4705882 0 0 0 1 0");

      svg.append('filter')
        .attr('id','Ok')
        .append('feColorMatrix')
        .attr('type','matrix')
        .attr('color-interpolation-filters', 'sRGB')
        .attr('values',"0 0 0 0 0.92941176 0 0 0 0 0.76470588 0 0 0 0 0.63921568 0 0 0 1 0");

      svg.append('filter')
        .attr('id','Bad')
        .append('feColorMatrix')
        .attr('type','matrix')
        .attr('color-interpolation-filters', 'sRGB')
        .attr('values',"0 0 0 0 0.79215686 0 0 0 0 0.380392156 0 0 0 0 0.30196078 0 0 0 1 0");

      svg.append('filter')
        .attr('id','Awful')
        .append('feColorMatrix')
        .attr('type','matrix')
        .attr('color-interpolation-filters', 'sRGB')
        .attr('values',"0 0 0 0 0.6235294 0 0 0 0 0.1490196 0 0 0 0 0.3568627 0 0 0 1 0");
    }

    /**
    *   keyList: list of keys, usually top 5/6 keys
    *   map: map of (all) keys to list of frequencies, ie "b5: {"Good": 3, "Ok": 5}"
    *   returns map of keys in keyList to mode of second breakdown, ie "b5: Ok"
    */
    function findMode(keyList, map) {
      let finalMap = {};

      keyList.forEach(function(id) {
        var keys = Object.keys(map[id]);
        var maxKey = "";
        var maxValue = 0;

        keys.forEach(function(reason) {
          if (map[id][reason] > maxValue) {
            maxKey = reason;
            maxValue = map[id][reason]
          }
        });

        finalMap[id] = maxKey;
      });
      
      return finalMap;
    }


    /**
    *   keyList: list of keys, usually top 5/6 keys
    *   map: map of (all) keys to list of frequencies, ie "b5: {"Good": 3, "Ok": 5}"
    *   returns map of keys in keyList to average moodLegend, starts at 0
    */
    function findAvgMood(keyList, map, isRounded = true) {
      let finalMap = {};
      let overallMax = 0;
      let overallMin = 1000000;

      keyList.forEach(function(id) {
        let keys = Object.keys(map[id]);
        let value = 0;
        let count = 0;

        keys.forEach(function(mood) {
          value = value + map[id][mood]*(moodList.indexOf(mood));
          count = count + map[id][mood];
        });

        if (value/count > overallMax) { overallMax = value/count;}
        if (value/count < overallMin) { overallMin = value/count;}

        finalMap[id] = isRounded ? Math.round(value/count) : value/count;
      });

      return finalMap;
    }

    /**
    *   keyList: list of keys, usually top 5/6 keys
    *   map: map of (all) keys to list of frequencies, ie "b5: {"Good": 3, "Ok": 5}"
    *   avgMap: map of keys to averages, ie "b5: 2.722"
    *   returns map of keys in keyList to average moodLegend, starts at 0
    */
    function findStdDevMood(keyList, map, avgMap) {
      let finalMap = {};

      keyList.forEach(function (id) {
        let keys = Object.keys(map[id]);
        let value = 0;
        let count = 0;

        keys.forEach(function(mood) {
          value = value + map[id][mood]*Math.pow(moodList.indexOf(mood) - avgMap[id], 2);
          count = count + map[id][mood];
        });

        finalMap[id] = Math.sqrt(value/count);
      });

      return finalMap;
     }

     function getTotalFrequencyFromMap(data) {
       let keys = Object.keys(data);
       let count = 0;

       keys.forEach(function(key) {
         count += data[key];
       });

       return count;
     }
    

    /**
    *   svgClass: tag for svg clas, must include the '.'
    *   categoryMap: map of short activity keys ("b5") to frequency 
    *   categoryFullMap: map of full activity keys ("Intellectual") to frequency
    *   title: title of graph
    *   personData: list of data entries
    *   returns void, draws data vis for line bar chart
    */
    function drawMoodByActvitiy(svgClass, categoryMap, categoryFullMap, title, personData) {
      let svg = d3.select(svgClass);

      let keyList = Array.from(categoryMap.keys()).slice(0, numIcons);
      let keyList2 = Array.from(categoryFullMap.keys()).slice(0, numIcons);
      // console.log(categoryFullMap)
      // console.log(keyList);
      // console.log(keyList2);

      let reasonByActivity = getFrequencyByKeys("Activity", "Reason", personData);
      let feelingByActivity = getFrequencyByKeys("Activity", "Feeling", personData);

      let reasonMap = findMode(keyList, reasonByActivity);
      let feelingMap = findMode(keyList, feelingByActivity);

      let avgMap = findAvgMood(keyList, feelingByActivity);
      let xScale = d3.scaleBand()
        .domain(keyList)
        .range([padding*2.5, width]);

      let yScale = d3.scaleLinear()
        .domain([0, d3.max(keyList, function(d) {return categoryMap.get(d)})])
        .range([height-padding*5, padding*2]);

      // add tooltip
      let tooltip = d3.select("body")
        .append("div")
        .style("padding", 10)
        .style("position", "absolute")
        .style("z-index", "10")
        .style("visibility", "hidden")
        .attr("white-space", "pre-line")
        .style("background-color", backgroundColor)
        .style("border-radius", "15px")
        .style("border", "1px solid #cdcdcd");

      // create initial bars
      svg.selectAll(".bars")
        .data(keyList)
        .enter()
        .append("line")
          .attr("x1", function(d) {return xScale(d)+10;})
          .attr("x2", function(d) {return xScale(d)+10;})
          .attr("y1", function(d) {return yScale(0);})
          .attr("y2", function(d) {return yScale(categoryMap.get(d))})
          .attr("stroke", function(d) { return colorHexArray[moodList[avgMap[d]]];})
          .attr("stroke-width", 2.5)
          .style("stroke-linecap", "round")
          .style("stroke-dasharray", function(d) {
            return dashArray[reasonMap[d]];
          });

      // add icons
      keyList.forEach(function(d, i) {
        svg.append('image')
          .attr('xlink:href', 'images/' + d + '.svg')
          .attr('x', xScale(keyList[i])-25)
          .attr('y', yScale(0)+10)
          .attr('width', iconWidth)
          .attr('height', iconWidth)
          .style('filter', function() {
            return 'url(#' + moodList[avgMap[keyList[i]]] +')';
          })
          .on("mousemove", function() {
            var tooltipText = "<b>ACTIVITY:</b> " + keyList2[i].split("(")[0].toLowerCase() +"</br></br><b>FREQUENCY: </b>" + categoryMap.get(d) + "</br></br><b>AVERAGE MOOD: </b>" + moodList[avgMap[keyList[i]]].toLowerCase() +
              "</br></br><b>MOST FREQUENT ATTITUDE: </b>" + attitudeLongtoShort[reasonMap[keyList[i]]];
            tooltip
                .html(tooltipText)
                .style("font-family", "Courier new")
                .style("font-size", 12)
                .style("text-align", "left")
                .style("color", textColor)
                .style("visibility", "visible")
                .style("max-width", 250)
                .style("top", event.pageY + 20)
                .style("left", function() {
                  if (d3.event.clientX < 750) {
                    return event.pageX + 20 +"px";
                  } else {
                    return event.pageX - 250 +"px";
                  }
                });
            }
          ).on("mouseout", function(d) {
            tooltip.style("visibility", "hidden");
          });
      });

      // add title
      svg.append('text')
        .attr('x', width/2)
        .attr('y', 50)
        .text(title)
        .style("font-family", "Courier new")
        .style("font-size", 25)
        .style("fill", textColor)
        .style("text-anchor", "middle");

      //add y axis
      let yAxis = d3.select(svgClass)
        .append("g")
            .attr("class", "y_axis")
            .attr("transform", "translate("+ (padding*1.5)+", 0)")
            .call(d3.axisRight(yScale).ticks(5).tickFormat(function(d, i, n) {
              return n[i+1] ? d : d + " records";
            }));
        yAxis.selectAll("text")
          .style("font-family", "Courier new")
          .style("text-anchor", "end")
          .style("fill", textColor)
          .style("font-size", 12);

        //add mood legend
        let moodLegend = d3.select(svgClass)
          .append("g")
          .attr("class", "moodLegend")
          .attr("transform", "translate("+ (padding*2) + ","+ (height-padding*2.5) +")");
        moodLegend.append("text")
          .attr("x", 2*padding*1.75)
          .attr("y", 15)
          .text("Average mood")
          // .style("font-weight", "bold")
          .style("text-anchor","middle")
          .style("font-family", "Courier new")
          .style("fill", textColor)
          .style("font-size", 12);
        moodLegend.selectAll(".moodDots")
          .data(moodList)
          .enter()
          .append('circle')
          .attr("cx", function(d, i) {return i*padding*1.75;})
          .attr("cy", padding*1)
          .attr("r", 5)
          .style("fill", function(d) { return colorHexArray[d];});
        moodLegend.selectAll(".moodText")
          .data(moodList)
          .enter()
          .append('text')
          .attr("x", function(d, i) {return i*padding*1.75;})
          .attr("y", padding*1.65)
          .text(function(d) {return d;})
          // .style("font-weight", "bold")
          .style("text-anchor","middle")
          .style("font-family", "Courier new")
          .style("fill", textColor)
          .style("font-size", 12);

        // add attitude legend
        let attitudeLegend = d3.select(svgClass)
          .append("g")
          .attr("class", "attitudeLegend")
          .attr("transform", "translate("+ (width-padding*9
            ) + ","+ (height-padding*2.5) +")");
        attitudeLegend.append("text")
          .attr("x", 2.5*padding*1.75+padding)
          .attr("y", 15)
          .text("Most frequent attitude")
          // .style("font-weight", "bold")
          .style("font-family", "Courier new")
          .style("text-anchor", "end")
          .style("fill", textColor)
          .style("font-size", 12);
        attitudeLegend.selectAll(".attText")
          .data(attitudeList)
          .enter()
          .append('text')
          .attr("x", function(d, i) {return i*padding*1.75+padding;})
          .attr("y", padding*1.65)
          .text(function(d) {return d;})
          .style("text-anchor","middle")
          // .style("font-weight", "bold")
          .style("font-family", "Courier new")
          .style("fill", textColor)
          .style("font-size", 12);
        attitudeLegend.selectAll(".attLine")
          .data(attitudeList)
          .enter()
          .append('line')
            .attr("x1", function(d, i) {return i*padding*1.75+padding;})
            .attr("x2", function(d, i) {return i*padding*1.75+padding;})
            .attr("y1", padding*1.2)
            .attr("y2", 35)
            .attr("stroke", textColor)
            .attr("stroke-width", 2.5)
            .style("stroke-linecap", "round")
            .style("stroke-dasharray", function(d, i) {
              return dashArray2[i];
            });
    }

    function drawBurst(svgClass, data, centerX, centerY, mood) {
      let svg = d3.select(svgClass); 
      let totalLines = getTotalFrequencyFromMap(data);
      let innerRadius = totalLines < 7 ? 0 : Math.floor(totalLines/4);
      let outerRadius = innerRadius + 12;

      let offset = totalLines < 18 ? 1 : 3;

      let radialScale = d3.scaleLinear()
        .domain([0, Math.floor(totalLines/offset)])
        .range([0, 2*Math.PI]);


      let count = 0;
      let keys = Object.keys(data);
      
      // drawing lines for single burst
      for (var i = 0; i < keys.length; i++) {
        let reason = keys[i];
        for (var j = 0; j < data[reason]; j+= offset) {
          svg.append("line")
          .attr("x1", centerX + innerRadius * Math.cos(radialScale(count)))
          .attr("x2", centerX + outerRadius * Math.cos(radialScale(count)))
          .attr("y1", centerY + innerRadius * Math.sin(radialScale(count)))
          .attr("y2", centerY + outerRadius * Math.sin(radialScale(count)))
          .attr("stroke", colorHexArray[mood])
          .attr("stroke-width", 2.5)
          .style("stroke-linecap", "round")
          .style("stroke-dasharray", dashArray[reason]);
          count += 1;
        }
      }
      
    }

    function drawMoodByActivityBursts(svgClass, categoryMap, personData, title) {
      let svg = d3.select(svgClass);

      let keyList = Array.from(categoryMap.keys()).slice(0, numIcons);
      // console.log(keyList);
      // console.log(personData);

      let reasonByActivity = getFrequencyByKeys("Activity", "Reason", personData);
      let feelingByActivity = getFrequencyByKeys("Activity", "Feeling", personData);
      let burstMap = getFrequencyByThreeKeys("Activity", "Feeling", "Reason", keyList, personData);
      // console.log(burstMap);

      let avgMap = findAvgMood(keyList, feelingByActivity, false);
      let stdDevMap = findStdDevMood(keyList, feelingByActivity, avgMap);

      let xScale = d3.scaleBand()
        .domain(keyList)
        .range([padding*2.5, width]);

      let yScale = d3.scaleLinear()
        .domain([0, 4])
        .range([height-padding*5, padding*2]);

      // draw std dev lines per activity
      svg.selectAll(".stdDevLines")
        .data(keyList)
        .enter()
        .append("line")
          .attr("x1", function(d) {return xScale(d)+10;})
          .attr("x2", function(d) {return xScale(d)+10;})
          .attr("y1", function(d) {return yScale(avgMap[d]-stdDevMap[d]);})
          .attr("y2", function(d) {return yScale(avgMap[d]+stdDevMap[d])})
          .attr("stroke", "#cdcdcd")
          .attr("stroke-width", 2.5)
          .style("opacity", 0.4)
          .style("stroke-linecap", "round");

      // draw dots for average mood per activity
      svg.selectAll(".avgDots")
        .data(keyList)
        .enter()
        .append("circle")
          .attr("cx", function(d) {return xScale(d)+10;})
          .attr("cy", function(d) {return yScale(avgMap[d]);})
          .attr("r", 5)
          .style("fill", function(d) {return colorHexArray[moodList[Math.round(avgMap[d])]];});

      
      keyList.forEach(function(activity, i) {
        // add icons
        svg.append('image')
          .attr('xlink:href', 'images/' + activity + '.svg')
          .attr('x', xScale(keyList[i])-25)
          .attr('y', yScale(0)+40)
          .attr('width', iconWidth)
          .attr('height', iconWidth)
          .style('filter', function() {
            return 'url(#' + moodList[Math.round(avgMap[keyList[i]])] +')';
          });


          //draw bursts
          Object.keys(burstMap[activity]).forEach(function(mood) {
            let burstData = burstMap[activity][mood];
            drawBurst(svgClass, burstData, xScale(keyList[i])+10, yScale(moodList.indexOf(mood)), mood);
          });
        });

      //add y axis
      let yAxis = d3.select(svgClass)
        .append("g")
            .attr("class", "y_axis")
            .attr("transform", "translate("+ (padding*1.5)+", 0)")
            .call(d3.axisRight(yScale).ticks(5).tickFormat(function(d) {
              return moodList[d];
            }));
        yAxis.selectAll("text")
          .style("font-family", "Courier new")
          .style("font-weight", "bold")
          .style("text-anchor", "end")
          .style("fill", function(d) { return colorHexArray[moodList[d]];})
          .style("font-size", 12);

      // add title
      svg.append('text')
        .attr('x', width/2)
        .attr('y', 35)
        .text(title)
        .style("font-family", "Courier new")
        .style("font-size", 25)
        .style("fill", textColor)
        .style("text-anchor", "middle")
    }

    function main() {
      setUpFilters(".indTwoWeeks");
      getData();
    }


    main();

  </script>
</body>

</html>
